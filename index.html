<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebTermTCP</title>
  <link href="bootstrap.min.css" rel="stylesheet">
  <style>
    /* Container for monitor and terminal outputs */
    #splitContainer {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 220px);
      border: 1px solid #555;
    }
    #monitor, #terminal {
      flex: 1;
      overflow-y: auto;
      white-space: pre-wrap;
      padding: 10px;
    }
    /* Updated output styles */
    #monitor {
      background-color: #fff;
      color: #000;
      border-bottom: 1px solid #555;
    }
    #terminal {
      background-color: #fff;
      color: blue;
      font-family: monospace;
    }
    /* One-line input styling */
    #inputField {
      height: 40px;
      font-family: monospace;
      padding: 5px;
    }
    /* Monitor options styling */
    #monitorOptions, #portList {
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid #aaa;
      background-color: #f8f8f8;
    }
    #portList {
      background-color: #f0f0f0;
    }
    #monitorOptions label, #portList label {
      margin-right: 15px;
    }
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type=number] {
      -moz-appearance: textfield;
    }
  </style>
</head>
<body>
  <div class="container my-4">
    <!-- Connection Settings -->
    <div class="row mb-2">
      <div class="col-md-2">
        <input type="text" id="host" class="form-control" placeholder="Host">
      </div>
      <div class="col-md-2">
        <input type="number" id="port" class="form-control" placeholder="Port">
      </div>
      <div class="col-md-2">
        <input type="text" id="username" class="form-control" placeholder="Username">
      </div>
      <div class="col-md-2">
        <input type="password" id="password" class="form-control" placeholder="Password">
      </div>
      <div class="col-md-2">
        <button id="connectBtn" class="btn btn-primary w-100">Connect</button>
      </div>
    </div>
    <!-- Monitor Options -->
    <div class="row mb-2">
      <div class="col-md-12">
        <div id="monitorOptions">
          <label><input type="checkbox" id="optMonitorTX" checked> Monitor TX</label>
          <label><input type="checkbox" id="optMonitorSup" checked> Monitor Supervisory</label>
          <label><input type="checkbox" id="optOnlyMonitorUI"> Only Monitor UI Frames</label>
          <label><input type="checkbox" id="optMonitorNodes" checked> Monitor Node Broadcasts</label>
          <label><input type="checkbox" id="optEnableColour" checked> Enable Colour</label>
        </div>
      </div>
    </div>
    <!-- Port List for Monitor -->
    <div class="row mb-2">
      <div class="col-md-12">
        <div id="portList">
          <em>No port information received yet.</em>
        </div>
      </div>
    </div>
    <!-- Split Output Area -->
    <div class="row">
      <div class="col">
        <div id="splitContainer">
          <div id="monitor"></div>
          <div id="terminal"></div>
        </div>
      </div>
    </div>
    <!-- Input Field -->
    <div class="row mt-2">
      <div class="col">
        <input type="text" id="inputField" class="form-control" placeholder="Type and press Enter">
      </div>
    </div>
  </div>

  <!-- Socket.IO and Bootstrap scripts -->
  <script src="socket.io.min.js"></script>
  <script src="bootstrap.bundle.min.js"></script>
  <script>
    let lastPortDef = "";
    // No extra monitor buffering nowâ€”data is parsed on the fly.
    const socket = io();
    const connectBtn = document.getElementById('connectBtn');
    const hostInput = document.getElementById('host');
    const portInput = document.getElementById('port');
    const usernameInput = document.getElementById('username');
    const passwordInput = document.getElementById('password');
    const portListDiv = document.getElementById('portList');
    const monitorOptionsDiv = document.getElementById('monitorOptions');
    const monitorDiv = document.getElementById('monitor');
    const terminalDiv = document.getElementById('terminal');
    const inputField = document.getElementById('inputField');
    let isConnected = false;
    let portMask = 0x1;
    
    // Utility: Remove unwanted control bytes.
    function bytesToCleanString(arr) {
      let allowed = [];
      for (let i = 0; i < arr.length; i++) {
        let b = arr[i];
        if (b !== 0xFE && b !== 0xFF && b !== 0x1B && b !== 0x11) {
          allowed.push(b);
        }
      }
      return String.fromCharCode(...allowed);
    }
    
    function logMessage(element, message) {
      message = message.replace(/[\r\n]+$/, "");
      element.innerHTML += message;
      element.scrollTop = element.scrollHeight;
    }
    
    function sendHandshake() {
      const username = usernameInput.value.trim();
      const password = passwordInput.value.trim();
      const handshake = username + "\r" + password + "\rBPQTERMTCP\r";
      socket.emit("data", handshake);
    }
    
    function getMonitorOptions() {
      const mtxparam = document.getElementById('optMonitorTX').checked ? "1" : "0";
      const mcomparam = document.getElementById('optMonitorSup').checked ? "1" : "0";
      const monUI = document.getElementById('optOnlyMonitorUI').checked ? "1" : "0";
      const MonitorNODES = document.getElementById('optMonitorNodes').checked ? "1" : "0";
      const MonitorColour = document.getElementById('optEnableColour').checked ? "1" : "0";
      return { mtxparam, mcomparam, monUI, MonitorNODES, MonitorColour };
    }
    
    function sendTraceOptions() {
      let maskHex = portMask.toString(16);
      const opts = getMonitorOptions();
      let cmd = "\\\\\\\\" + maskHex + " " + opts.mtxparam + " " + opts.mcomparam + " " +
                opts.MonitorNODES + " " + opts.MonitorColour + " " + opts.monUI + " 0 1\r";
      socket.emit("data", cmd);
    }
    
    const monitorOptionCheckboxes = monitorOptionsDiv.querySelectorAll("input[type=checkbox]");
    monitorOptionCheckboxes.forEach(cb => {
      cb.addEventListener("change", sendTraceOptions);
    });
    
    function updatePortMask() {
      portMask = 0;
      const checkboxes = portListDiv.querySelectorAll("input[type=checkbox]");
      checkboxes.forEach(cb => {
        if (cb.checked) {
          let portnum = parseInt(cb.value, 10);
          portMask |= (1 << (portnum - 1));
        }
      });
      sendTraceOptions();
    }
    
    function initiatePortMonitoring() {
      sendHandshake();
      sendTraceOptions();
    }
    
    connectBtn.addEventListener('click', () => {
      if (!isConnected) {
        const host = hostInput.value.trim();
        const port = parseInt(portInput.value.trim(), 10);
        if (!host || isNaN(port)) {
          alert("Please enter valid host and port");
          return;
        }
        fetch("/api", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action: "connect", client_id: socket.id, host: host, port: port })
        })
        .then(response => response.json())
        .then(data => {
          if (data.status === "success") {
            isConnected = true;
            connectBtn.innerText = "Disconnect";
            logMessage(terminalDiv, "Connected to " + host + ":" + port + "<br>");
            localStorage.setItem("host", host);
            localStorage.setItem("port", portInput.value.trim());
            localStorage.setItem("username", usernameInput.value.trim());
            localStorage.setItem("password", passwordInput.value.trim());
            initiatePortMonitoring();
          } else {
            alert("Failed to connect");
          }
        })
        .catch(err => {
          console.error(err);
          alert("Error connecting");
        });
      } else {
        fetch("/api", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action: "disconnect", client_id: socket.id })
        })
        .then(response => response.json())
        .then(data => {
          if (data.status === "success") {
            isConnected = false;
            connectBtn.innerText = "Connect";
            logMessage(terminalDiv, "Disconnected<br>");
          } else {
            alert("Failed to disconnect");
          }
        })
        .catch(err => {
          console.error(err);
          alert("Error disconnecting");
        });
      }
    });
    
    window.addEventListener("load", () => {
      hostInput.value = localStorage.getItem("host") || "127.0.0.1";
      portInput.value = localStorage.getItem("port") || "8011";
      usernameInput.value = localStorage.getItem("username") || "";
      passwordInput.value = localStorage.getItem("password") || "";
    });
    
    // --- New Data Processing Approach ---

  socket.on("data", (data) => {
    let arr;
    if (data instanceof ArrayBuffer) {
      arr = new Uint8Array(data);
    } else if (typeof data === "string") {
      arr = new Uint8Array(data.split('').map(c => c.charCodeAt(0)));
    } else {
      console.error("Unexpected data type", typeof data);
      return;
    }
    
    let pos = 0;
    while (pos < arr.length) {
      // If the byte is 0xFF, it may be a monitor message or port definition.
      if (arr[pos] === 0xFF) {
        // Check if it's a port definition (two leading 0xFF).
        if (pos + 1 < arr.length && arr[pos+1] === 0xFF) {
          let portDef = String.fromCharCode(...arr.slice(pos+2));
          console.log("Port definition received:", portDef);
          if (portDef !== lastPortDef) {
            lastPortDef = portDef;
            let tokens = portDef.split("|");
            portListDiv.innerHTML = "";
            for (let i = 1; i < tokens.length; i++) {
              let token = tokens[i].trim();
              if (token) {
                let portnum = parseInt(token, 10);
                let checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.value = portnum;
                if (portnum === 1) { checkbox.checked = true; }
                checkbox.addEventListener("change", updatePortMask);
                let label = document.createElement("label");
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(" " + token));
                portListDiv.appendChild(label);
              }
            }
            updatePortMask();
          }
          // Consume entire port definition and break out.
          break;
        } else {
          // We have a monitor message.
          let color = "blue"; // default for received messages
          let start = pos + 1;
          // Check if next byte is the ESC (0x1B) which indicates special handling.
          if (pos + 1 < arr.length && arr[pos+1] === 0x1B) {
            // Look at the following byte to decide if transmitted or received.
            if (pos + 2 < arr.length) {
              if (arr[pos+2] === 0x5B) {
                color = "red";  // transmitted
                start = pos + 3;
              } else if (arr[pos+2] === 0x11) {
                color = "blue"; // received
                start = pos + 3;
              } else {
                // Unknown control; default to transmitted.
                color = "red";
                start = pos + 2;
              }
            } else {
              // Not enough bytes; break out and wait for more data.
              break;
            }
          }
          // Find the termination marker 0xFE.
          let feIndex = arr.indexOf(0xFE, start);
          if (feIndex !== -1) {
            // Before the monitor marker, output any normal text if present.
            if (pos > 0) {
              let normalPart = arr.slice(0, pos);
              let text = bytesToCleanString(normalPart).replace(/\r/g, "<br>");
              logMessage(terminalDiv, text);
            }
            // Extract the monitor message between the start and the termination marker.
            let monitorData = arr.slice(start, feIndex);
            let monitorText = bytesToCleanString(monitorData).replace(/\r/g, "\n");
            let span = document.createElement("span");
            span.style.color = color;
            span.textContent = monitorText;
            monitorDiv.appendChild(span);
            monitorDiv.scrollTop = monitorDiv.scrollHeight;
            // Continue processing after the termination marker.
            arr = arr.slice(feIndex + 1);
            pos = 0;
            continue;
          } else {
            // No termination marker found. Treat the remaining as normal text.
            let text = bytesToCleanString(arr.slice(pos)).replace(/\r/g, "<br>");
            logMessage(terminalDiv, text);
            break;
          }
        }
      } else {
        // No monitor marker at the current position; output as normal terminal text.
        let nextFF = arr.indexOf(0xFF, pos);
        if (nextFF === -1) nextFF = arr.length;
        let normalData = arr.slice(pos, nextFF);
        let text = bytesToCleanString(normalData).replace(/\r/g, "<br>");
        logMessage(terminalDiv, text);
        pos = nextFF;
      }
    }
  });

    
    socket.on("tcp_disconnect", (message) => {
      logMessage(terminalDiv, "TCP disconnected: " + message + "<br>");
      isConnected = false;
      connectBtn.innerText = "Connect";
    });
    
    inputField.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        const rawText = inputField.value;
        if (rawText) {
          const message = rawText.replace(/\n/g, "\r") + "\r";
          socket.emit("data", message);
          terminalDiv.innerHTML += "<br>" + rawText + "<br>";
          terminalDiv.scrollTop = terminalDiv.scrollHeight;
          inputField.value = "";
        }
      }
    });
    
    setInterval(() => {
      if (isConnected) {
        socket.emit("data", "\0");
      }
    }, 540000);
  </script>
</body>
</html>
